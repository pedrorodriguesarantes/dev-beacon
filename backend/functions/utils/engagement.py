"""engagement.py – Community engagement‑focused metrics

This module mirrors the style of *newcomers.py* and provides a family of
helper functions that calculate engagement and robustness indicators for an
open‑source project.  All functions are **pure** (no I/O) and expect clean
`pandas.DataFrame`s as inputs.

Each metric returns either a scalar value **or** a list of `{x, y}` dicts
ready to be serialised as JSON for the dashboard layer, following the same
convention used by `newcomers.py`.

Required columns for the DataFrames (case‑sensitive):
    * `user`         – login / handle of the contributor
    * `created_at`   – UTC timestamp (parseable by `pd.to_datetime`)
    * `labels`       – (for issues only) list *or* string representation
    * `state`        – (for issues only) 'open', 'closed', …

If additional columns are necessary, they are documented at function level.
"""

from __future__ import annotations

from collections.abc import Iterable
from datetime import datetime, timedelta, timezone
from typing import List, Tuple

import numpy as np
import pandas as pd

###############################################################################
# Constants & helpers
###############################################################################

TODAY = datetime.now(timezone.utc)
ONE_WEEK = timedelta(days=7)
HALF_YEAR = timedelta(days=182)
ONE_YEAR = timedelta(days=365)

def get_periods(period: str = "day", *, n: int = 30, cutoff_days: int = 0) -> List[Tuple[datetime, datetime]]:
    """Replica of newcomers.get_periods – returns `n` consecutive periods.

    Args:
        period: 'day' | 'week' | 'month'
        n: number of periods to return *before* `cutoff_days`.
        cutoff_days: gap between *now* and the most recent returned period;
            lets you freeze data for incomplete current windows.
    """
    now = datetime.now(timezone.utc)
    periods: List[Tuple[datetime, datetime]] = []

    if period == "day":
        today = now.date()
        start_day = today - timedelta(days=cutoff_days + n)
        for i in range(n):
            start = start_day + timedelta(days=i)
            end = start + timedelta(days=1)
            periods.append((start, end))

    elif period == "week":
        this_monday = (now - timedelta(days=now.weekday())).date()
        start_monday = this_monday - timedelta(weeks=cutoff_days // 7 + n)
        for i in range(n):
            start = start_monday + timedelta(weeks=i)
            end = start + timedelta(weeks=1)
            periods.append((start, end))

    elif period == "month":
        current = now.replace(day=1)
        start_month = current - pd.DateOffset(months=cutoff_days // 30 + n)
        current_month = pd.Timestamp(start_month)
        for _ in range(n):
            start = current_month.date()
            end = (current_month + pd.offsets.MonthBegin(1)).date()
            periods.append((start, end))
            current_month += pd.offsets.MonthBegin(1)

    else:
        raise ValueError("Invalid period – use 'day', 'week', or 'month'.")

    return periods


def gini(array: Iterable[float | int]) -> float:
    """Calculate the Gini coefficient of a numpy array.

    Straight copy from the textbook implementation, guarding against empty
    arrays and normalising the result to the 0–1 interval.
    """
    arr = np.array(list(array), dtype=float)
    if arr.size == 0:
        return float('nan')

    # Values must be non‑negative
    arr = np.abs(arr)
    if arr.sum() == 0:
        return 0.0

    arr_sorted = np.sort(arr)
    n = arr_sorted.size
    cum = np.cumsum(arr_sorted)
    g = (n + 1 - 2 * np.sum(cum) / cum[-1]) / n
    return round(g, 4)

###############################################################################
# Metric 1 – Active Chat Participation Rate (weekly)
###############################################################################

def metric_active_chat_participation_rate(
    chat_df: pd.DataFrame,
    contrib_df: pd.DataFrame,
    pts: List[Tuple[datetime, datetime]],
    *,
    window: timedelta = ONE_WEEK,
) -> List[dict]:
    """Share of code contributors who posted *≥1* chat message in last week.

    chat_df   – columns: ['user', 'created_at']
    contrib_df – code contributions (commits, PRs, etc.) with same columns.
    pts        – periods generated by `get_periods` (granularity agnostic).
    """
    chat_df['created_at'] = pd.to_datetime(chat_df['created_at'], utc=True)
    contrib_df['created_at'] = pd.to_datetime(contrib_df['created_at'], utc=True)

    out: List[dict] = []
    for start_date, end_date in pts:
        end_ts = pd.Timestamp(end_date, tz='UTC')
        start_ts = end_ts - window

        chat_users = (
            chat_df.loc[(chat_df['created_at'] >= start_ts) & (chat_df['created_at'] < end_ts), 'user']
            .unique()
        )
        code_users = (
            contrib_df.loc[(contrib_df['created_at'] >= start_ts) & (contrib_df['created_at'] < end_ts), 'user']
            .unique()
        )

        if code_users.size == 0:
            rate = None
        else:
            rate = round(len(np.intersect1d(chat_users, code_users)) / code_users.size * 100, 2)

        out.append({"x": start_date.strftime('%Y-%m-%d'), "y": rate})

    return out

###############################################################################
# Metric 2 – Average Labels per Open Issue (snapshot)
###############################################################################

def metric_avg_labels_per_open_issue(issues_df: pd.DataFrame) -> float | None:
    """Return the mean number of labels attached to currently *open* issues.

    `labels` column may contain a *list* or a comma‑separated string.
    """
    if issues_df.empty:
        return None

    open_issues = issues_df[issues_df['state'] == 'open']
    if open_issues.empty:
        return None

    def _count_labels(val):
        if pd.isna(val):
            return 0
        if isinstance(val, list):
            return len(val)
        if isinstance(val, str):
            return len([lbl.strip() for lbl in val.split(',') if lbl.strip()])
        return 0

    label_counts = open_issues['labels'].apply(_count_labels)
    return round(label_counts.mean(), 2)

###############################################################################
# Metric 3 – Committer Churn Rate (core retention)
###############################################################################

def metric_committer_churn_rate(
    commit_df: pd.DataFrame,
    *,
    as_of: datetime | None = None,
    window_current: timedelta = HALF_YEAR,
    window_prev: timedelta = ONE_YEAR,
) -> float | None:
    """Percent of committers active in *previous year* but inactive in *current* six‑month window.

    • commit_df columns: ['user', 'created_at'] (UTC timestamps)
    """
    if commit_df.empty:
        return None

    commit_df['created_at'] = pd.to_datetime(commit_df['created_at'], utc=True)
    as_of = as_of or TODAY

    current_start = as_of - window_current
    prev_start = current_start - window_prev

    committers_last_year = commit_df.loc[(commit_df['created_at'] >= prev_start) & (commit_df['created_at'] < current_start), 'user'].unique()
    if committers_last_year.size == 0:
        return None

    committers_current = commit_df.loc[(commit_df['created_at'] >= current_start) & (commit_df['created_at'] < as_of), 'user'].unique()

    churned = np.setdiff1d(committers_last_year, committers_current, assume_unique=True)
    rate = len(churned) / committers_last_year.size * 100
    return round(rate, 2)

###############################################################################
# Metric 4 – Committer Concentration (Gini coefficient)
###############################################################################

def metric_committer_concentration_gini(
    commit_df: pd.DataFrame,
    period_start: datetime | pd.Timestamp,
    period_end: datetime | pd.Timestamp,
) -> float | None:
    """Gini on commit distribution amongst committers inside a window."""
    if commit_df.empty:
        return None

    commit_df['created_at'] = pd.to_datetime(commit_df['created_at'], utc=True)
    mask = (commit_df['created_at'] >= period_start) & (commit_df['created_at'] < period_end)
    window_df = commit_df.loc[mask]
    if window_df.empty:
        return None

    commits_per_user = window_df.groupby('user').size().values
    return gini(commits_per_user)

###############################################################################
# Metric 5 – Contributor Growth Rate (year‑on‑year)
###############################################################################

def metric_contributor_growth_rate_yoy(contrib_df: pd.DataFrame) -> List[dict]:
    """Return list of YoY growth rates for each calendar year present."""
    if contrib_df.empty:
        return []

    contrib_df['created_at'] = pd.to_datetime(contrib_df['created_at'], utc=True)
    contrib_df['year'] = contrib_df['created_at'].dt.year

    yearly_counts = contrib_df.groupby('year')['user'].nunique().sort_index()
    out: List[dict] = []
    prev_count: int | None = None
    for year, count in yearly_counts.items():
        if prev_count is None or prev_count == 0:
            growth = None
        else:
            growth = round(((count - prev_count) / prev_count) * 100, 2)
        out.append({"x": str(year), "y": growth})
        prev_count = count

    return out

###############################################################################
# Metric 6 – Count of Occasional Contributors
###############################################################################

def metric_count_of_occasional_contributors(
    contrib_df: pd.DataFrame,
    *,
    k: int = 3,
    window: timedelta = ONE_YEAR,
    as_of: datetime | None = None,
) -> int | None:
    """Number of contributors with ≤ *k* contributions in last *window* (default 365 d)."""
    if contrib_df.empty:
        return None

    contrib_df['created_at'] = pd.to_datetime(contrib_df['created_at'], utc=True)
    as_of = as_of or TODAY
    window_start = as_of - window

    window_df = contrib_df.loc[
        (contrib_df['created_at'] >= window_start) & 
        (contrib_df['created_at'] < as_of)
    ]
    if window_df.empty:
        return 0

    contrib_counts = window_df.groupby('user').size()
    occasional = contrib_counts[contrib_counts <= k].size
    return int(occasional)

###############################################################################
# Metric 6 – Count of Occasional Contributors
###############################################################################

def metric_count_of_occasional_contributors(
    contrib_df: pd.DataFrame,
    *,
    k: int = 3,
    window: timedelta = ONE_YEAR,
    as_of: datetime | None = None,
) -> int | None:
    """
    Return the number of *occasional* contributors — developers who have made
    **≤ `k`** contributions during the trailing `window` (default 365 days).

    Parameters
    ----------
    contrib_df : pd.DataFrame
        Must contain columns **'user'** and **'created_at'** (UTC timestamps).
        One row per contribution (commit, merged PR, etc.).
    k : int, default 3
        Threshold for occasional status (≤ k contributions ⇒ occasional).
    window : timedelta, default ONE_YEAR
        Look‑back period ending at `as_of`.
    as_of : datetime | None, default None
        Reference moment.  If None, uses *now* (UTC).

    Returns
    -------
    int | None
        Count of occasional contributors, or None if `contrib_df` is empty.
    """
    if contrib_df.empty:
        return None  # nothing to compute

    # --- ensure created_at is timezone‑aware datetime -------------------- #
    contrib_df = contrib_df.copy()
    contrib_df["created_at"] = pd.to_datetime(
        contrib_df["created_at"], errors="coerce", utc=True
    )

    as_of = as_of or TODAY
    window_start = as_of - window

    # --- slice to trailing window --------------------------------------- #
    window_df = contrib_df[
        (contrib_df["created_at"] >= window_start)
        & (contrib_df["created_at"] < as_of)
    ]

    if window_df.empty:
        return 0  # no contributions in window ⇒ zero occasional contributors

    # --- count contributions per user ----------------------------------- #
    contrib_counts = window_df.groupby("user").size()

    # --- contributors with ≤ k events ----------------------------------- #
    occasional = contrib_counts[contrib_counts <= k].size
    return int(occasional)
